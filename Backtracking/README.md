# 回溯法

 - 回溯法的算法框架
    1. 问题的解空间
        1. 问题的解空间至少包含问题的一个(最优)解
        2. 还应将解空间很好的组织起来，通常将解空间组织成树或图的形式。
    2. 回溯法的基本思想
        1. 从根结点出发，以深度优先的方式搜索解空间。
        2. 开始结点成为活节点，并且也成为当前的扩展结点。
        3. 在当前扩展结点处，以深度优先的方式扩展。
        4. 新结点成为活节点，并且成为可扩展结点。
        5. 回溯法搜索解空间树时，通常采用两种策略避免无效搜索，提高回溯法的搜索效率：
            1. 用约束函数在扩展结点处剪去不满足约束的子树。
            2. 用界限函数剪去得不到最优解的子树。
    3. 递归回溯
        ```
        void backtrack(int t){
            if(t>n) output(x);
            else
                for(int i=f(n,t);i<=g(n,t);i++){
                    x[t]=h(i);
                    if(constraint(t)&&bound(t)) backtrack(t+1);
                }
        }
       ```
    4. 迭代回溯
        1. 采用树的非递归深度优先遍历算法。
        ```
        void interactiveBacktrack()
        {
            int i=1;
            while(t>0)
            {
                if(f(n,t)<=g(n,t))
                {
                    for(i=f(n,t);i<=g(n,t);i++)
                    {
                        x[t]=h(i);
                        if(constraint(t)&&bound(t))
                        {
                            if(solution(t)) output(x);
                            else t++;
                        }
                    }
                }
                else t--;
            }
        }
        ```
    5. 子集树和排列树
        1. 子集树：通常这类树有2^n个叶结点，遍历子集树的算法需要Ω(2^n)计算时间。
        2. 排列树：通常这类树有n!个 叶结点，遍历排列树的算法需要Ω(n!)计算时间。